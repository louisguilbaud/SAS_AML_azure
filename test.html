<!--
Written by Arnav Priyadarshi
Date: August 2024
arnav.priyadarshi@sas.com
-->
<!DOCTYPE html>
<html lang="en">
	<head>
		<script src="./javascripts/sas/util/messagingUtil.js"></script>
		<script
			type="module"
			src="https://md-block.verou.me/md-block.js"
		></script>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<style>
			body {
				font-family: Arial, sans-serif;
				font-size: 16px;
				width: 80%;
				height: 100vh;
				display: flex;
				flex-direction: column;
				margin: auto;
				min-height: 100vh;
			}

			pre {
				white-space: pre-wrap;
				font-family: monospace;
				font-size: 14px;
			}

			details {
				margin: 20px 0;
				border: 1px solid #ccc;
				border-radius: 5px;
				padding: 10px;
				display: none;
			}

			summary {
				font-size: 24px;
				font-weight: bold;
				cursor: pointer;
			}

			.btn-primary {
				background-color: #007bff;
				border-color: #0a4079;
				color: #fff;
				padding: 10px 40px;
				font-size: 16px;
				cursor: pointer;
				margin: 20px;
				/* inset */
				border-radius: 5px;
				box-shadow: inset 0px 0px 0px -0.1px #0a0a0a;
			}

			label {
				margin-bottom: 10px;
			}

			textarea {
				width: 90%;
				min-height: 80px;
				font-family: system-ui, -apple-system, BlinkMacSystemFont,
					"Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans",
					"Helvetica Neue", sans-serif;
				text-wrap: wrap;
				height: auto;
				overflow: hidden;
				resize: none;
				padding: 0.8em;
				font-size: 16px;
			}

			.row {
				padding-top: 10px;
			}

			#chatgptResponse {
				font-family: system-ui, -apple-system, BlinkMacSystemFont,
					"Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans",
					"Helvetica Neue", sans-serif;
				color: #02022f;
			}

			.loading {
				display: none;
			}

			.chat {
				display: flex;
				flex-direction: column;
				align-items: center;
				height: 100%;
				flex: 1;
			}

			#conversation {
				display: flex;
				flex-direction: column;
				align-items: center;
				margin: 20px;
				width: 100%;
				border-radius: 5px;
				background-color: #fefeff;
				margin-bottom: 40px;
			}

			.message {
				margin: 0 10px 15px 10px;
				padding: 10px;
				border-radius: 5px;
				background-color: #eeeeee;
				box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
				max-width: 100%;
				line-height: 1.5;
				font-family: system-ui, -apple-system, BlinkMacSystemFont,
					"Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans",
					"Helvetica Neue", sans-serif;
			}

			.assistant-response {
				/* the box is aligned to the left inside #conversation */
				align-self: flex-start;
				color: #010721;
			}

			.user-response {
				/* the box is aligned to the right inside #conversation */
				align-self: flex-end;
			}

			#chatForm {
				flex: 0;
				display: flex;
				flex-direction: column;
				margin: 10px;
				align-items: center;
				justify-content: center;
				margin-top: auto;
				padding-bottom: 2rem;
			}

			.prompt {
				display: none;
			}
			.tab {
				overflow: hidden;
				border: 1px solid #ccc;
				background-color: #f1f1f1;
			}
			.tab button {
				background-color: inherit;
				float: left;
				border: none;
				outline: none;
				cursor: pointer;
				padding: 14px 16px;
				transition: 0.3s;
			}
			.tab button:hover {
				background-color: #ddd;
			}
			.tab button.active {
				background-color: #ccc;
			}
			.tabcontent {
				display: none;
				padding: 6px 12px;
				border: 1px solid #ccc;
				border-top: none;
			}
		</style>
		<title>AML LLM</title>
	</head>

	<body>
		<details>
			<summary>API Response</summary>
			<h2>API response</h2>
			<pre id="apiResponse"></pre>
			<h2>Filtered Scenario Fired Events</h2>
			<pre id="scenario_fired_event"></pre>
			<h2>Filtered Transactions</h2>
			<pre id="transactions"></pre>
			<h2>Personal Information</h2>
			<pre id="Party_info"></pre>
			<h2>Nonnormalized graph</h2>
			<pre id="postResponse"></pre>
		</details>
		<details>
			<summary>Graph Of Transactions</summary>
			<h2>Vertices JSON</h2>
			<pre id="verticesJson"></pre>
			<h2>Edges JSON</h2>
			<pre id="edgesJson"></pre>
			<p id="alertid"></p>
		</details>

		<div class="tab">
			<button
				class="tablinks"
				onclick="openTab(event, 'CaseNarrative')"
				id="defaultOpen"
			>
				Case Narrative
			</button>
			<button class="tablinks" onclick="openTab(event, 'QnA')">
				QnA
			</button>
		</div>

		<div id="QnA" class="tabcontent">
			<div class="chat">
				<div id="conversation">
					<h2 class="loading" id="loading-indicator">
						Loading response
					</h2>
				</div>
				<form id="chatForm">
					<br />
					<div class="row">
						<label for="model">Model:</label>
						<select id="model" name="model">
							<option value="gpt-4o">GPT-4o</option>
							<option value="gpt-4o-mini">GPT-4o mini</option>
						</select>
					</div>
					<button
						type="submit"
						class="btn-primary"
						id="callApiButton"
					>
						Get Case Narrative
					</button>
				</form>
			</div>
		</div>

		<div id="CaseNarrative" class="tabcontent">
			<div class="chat">
				<div id="conversation-cn">
					<h2 class="loading" id="loading-indicator-cn">
						Loading response
					</h2>
				</div>
				<form id="chatForm-cn">
					<br />
					<div class="row">
						<label for="model-cn">Model:</label>
						<select id="model-cn" name="model">
							<option value="gpt-4o">GPT-4o</option>
							<option value="gpt-4o-mini">GPT-4o mini</option>
						</select>
					</div>
					<button
						type="submit"
						class="btn-primary"
						id="callApiButton-cn"
					>
						Get Case Narrative
					</button>
				</form>
			</div>
		</div>

		<p hidden><span id="apiKeyContainer"></span></p>
		<p hidden><span id="alertid"></span></p>

		<script>
			"use strict";

			function openTab(evt, tabName) {
				var i, tabcontent, tablinks;
				tabcontent = document.getElementsByClassName("tabcontent");
				for (i = 0; i < tabcontent.length; i++) {
					tabcontent[i].style.display = "none";
				}
				tablinks = document.getElementsByClassName("tablinks");
				for (i = 0; i < tablinks.length; i++) {
					tablinks[i].className = tablinks[i].className.replace(
						" active",
						""
					);
				}
				document.getElementById(tabName).style.display = "block";
				evt.currentTarget.className += " active";
			}

			// Open the default tab
			document.getElementById("defaultOpen").click();

			function autoGrow(element) {
				element.style.height = "auto";
				element.style.height = element.scrollHeight + "px";
			}

			const body = document.querySelector("body");

			// Attach the autoGrow function to input event for all textareas
			document.querySelectorAll("textarea").forEach(textarea => {
				textarea.addEventListener("input", function () {
					autoGrow(this);
					autoGrow(body);
				});
				// Call autoGrow on page load to set initial height
				autoGrow(textarea);
				autoGrow(body);
			});

			const myHeaders = new Headers();
			myHeaders.append(
				"Cookie",
				"sas-ingress-nginx=6866adc2289a112d6ea7fd0775261540|f0e9e5d83f1b459459b54939af4feb2b"
			);

			const requestOptions = {
				method: "GET",
				headers: myHeaders,
				redirect: "follow"
			};

			// TODO: remove this comment
			va.messagingUtil.setOnDataReceivedCallback(updateURL);

			function updateURL(vaMsgObj) {
				console.log("Received vaMsgObj:", vaMsgObj);
				if (vaMsgObj && vaMsgObj.data && vaMsgObj.data.length > 0) {
					const apiKey = vaMsgObj.data[0][0];
					console.log("[debug]: Fetched API Key:", apiKey);
					document.getElementById("apiKeyContainer").textContent =
						apiKey;

					// Extract the value from the parameters array
					if (vaMsgObj.parameters && vaMsgObj.parameters.length > 0) {
						const alert_id = vaMsgObj.parameters[0].value;
						console.log(
							"[debug]: Fetched Parameter Value:",
							alert_id
						);
						document.getElementById("alertid").textContent =
							alert_id;
					} else {
						document.getElementById("alertid").textContent =
							"No parameter value available";
					}
				} else {
					document.getElementById("apiKeyContainer").textContent =
						"No API key available";
					document.getElementById("alertid").textContent =
						"No parameter value available";
				}
			}

			async function getCsrfToken() {
				const url =
					"https://sasserver.demo.sas.com/svi-sand/traversals?calculateMetrics=false&expansionLimit=2000";
				try {
					const response = await fetch(url, {
						method: "GET",
						credentials: "include"
					});
					const csrfToken = response.headers.get("X-CSRF-TOKEN");
					if (!csrfToken) {
						console.error(
							"CSRF token not found in response headers"
						);
						throw new Error(
							"CSRF token not found in response headers"
						);
					}
					console.log("[debug]: csrfToken set");
					return csrfToken;
				} catch (error) {
					console.error("[debug]: Error in getCsrfToken:", error);
					throw error;
				}
			}

			async function postData(csrfToken) {
				const url =
					"https://sasserver.demo.sas.com/svi-sand/traversals?calculateMetrics=false&expansionLimit=2000";
				const data = {
					edgeTypes: ["social_link"],
					depth: 2,
					extendedFormat: true,
					graphObjectIds: [
						{
							type: "PTY",
							id: "326315"
						},
						{
							type: "alerts",
							id: "3d9a7119-640a-420a-a273-e7f0520259f4"
						}
					],
					query: {
						type: "object",
						objectIds: [
							{
								type: "PTY",
								id: "326315"
							}
						]
					}
				};

				const myHeaderspost = new Headers();
				myHeaderspost.append("Content-Type", "application/json");
				myHeaderspost.append(
					"Cookie",
					"sas-ingress-nginx=465a78167134495424fe1d90f9dbaa56|12b794cb5ca279bec1edb7e510234855"
				);
				myHeaderspost.append("X-CSRF-TOKEN", csrfToken);

				const requestOptionspost = {
					method: "POST",
					headers: myHeaderspost,
					body: JSON.stringify(data),
					redirect: "follow"
				};

				try {
					const response = await fetch(url, requestOptionspost);
					if (!response.ok) {
						throw new Error(
							"Network response was not ok " + response.statusText
						);
					}
					const postResponseText = await response.json();
					document.getElementById("postResponse").textContent =
						JSON.stringify(postResponseText, null, 2);

					const vertices = postResponseText.vertices.map(vertex => ({
						type: vertex.type,
						id: vertex.id,
						typeLabel: vertex.typeLabel,
						label: vertex.label
					}));

					const edges = postResponseText.edges.map(edge => ({
						id: edge.id,
						endpoints: edge.endpoints.map(endpoint => ({
							type: endpoint.type,
							id: endpoint.id
						})),
						subtype: edge.subtype,
						label: edge.label
					}));

					console.log("[debug]: set pty and graph data");

					document.getElementById("verticesJson").textContent =
						JSON.stringify(vertices, null, 2);
					document.getElementById("edgesJson").textContent =
						JSON.stringify(edges, null, 2);
				} catch (error) {
					console.error("[debug]: Error in postData:", error);
					document.getElementById(
						"postResponse"
					).textContent = `Error: ${error}`;
				}
			}

			async function fetchData() {
				const alertIdElement = document.getElementById("alertid");
				let alertId = alertIdElement.textContent.trim(); // Get the alert ID from the element

				if (!alertId) {
					console.warn(
						"[debug]: Alert ID is not immediately available. Waiting for it to be populated..."
					);

					// Wait for the alert ID to be available
					for (let i = 0; i < 10; i++) {
						// Retry up to 10 times (adjust as needed)
						await new Promise(resolve => setTimeout(resolve, 500)); // Wait for 500ms
						alertId = alertIdElement.textContent.trim();
						if (alertId) {
							break; // Exit the loop once alertId is available
						}
					}
				}

				if (!alertId) {
					console.error(
						"Alert ID is still not available after waiting."
					);
					return;
				}
				const alertUrl = `https://sasserver.demo.sas.com/svi-alert/alerts/${alertId}`;

				console.log("[debug]: called alerts data");
				try {
					const response = await fetch(alertUrl, requestOptions);
					if (!response.ok) {
						throw new Error(
							"Network response was not ok " + response.statusText
						);
					}
					const data = await response.json();
					const currentAlertingEventId = data.currentAlertingEventId;
					const actionableEntityId = data.actionableEntityId;
					document.getElementById("apiResponse").innerHTML =
						JSON.stringify(data, null, 2);

					const alertingEventsUrl = `https://sasserver.demo.sas.com/svi-alert/alertingEvents/${currentAlertingEventId}`;
					const alertingEventsResponse = await fetch(
						alertingEventsUrl,
						requestOptions
					);
					if (!alertingEventsResponse.ok) {
						throw new Error(
							"Network response was not ok " +
								alertingEventsResponse.statusText
						);
					}
					const alertingEventsData =
						await alertingEventsResponse.json();
					const filteredScenarioFiredEvents =
						alertingEventsData.scenarioFiredEvents.map(event => ({
							scenarioName: event.scenarioName,
							scenarioDescription: event.scenarioDescription,
							messageTemplateText: event.messageTemplateText
						}));
					document.getElementById("scenario_fired_event").innerHTML =
						JSON.stringify(filteredScenarioFiredEvents, null, 2);

					const transactionsUrl = `https://sasserver.demo.sas.com/amlCore/transactions?entityLevelCode=PTY&entityNumber=${actionableEntityId}`;
					const transactionsResponse = await fetch(
						transactionsUrl,
						requestOptions
					);
					if (!transactionsResponse.ok) {
						throw new Error(
							"Network response was not ok " +
								transactionsResponse.statusText
						);
					}
					const transactionsData = await transactionsResponse.json();
					const filteredTransactions = transactionsData.items.map(
						transaction => ({
							transactionNumber: transaction.transactionNumber,
							transactionDate: transaction.transactionDate,
							primaryMediumDesc: transaction.primaryMediumDesc,
							secondaryMediumDesc:
								transaction.secondaryMediumDesc,
							mechanismDesc: transaction.mechanismDesc,
							currencyAmount: transaction.currencyAmount,
							transactionCDIDesc: transaction.transactionCDIDesc
						})
					);
					document.getElementById("transactions").innerHTML =
						JSON.stringify(filteredTransactions, null, 2);

					const partyInfoUrl = `https://sasserver.demo.sas.com/SASVisualInvestigator/pages/PTY/${actionableEntityId}`;
					const partyInfoResponse = await fetch(
						partyInfoUrl,
						requestOptions
					);
					if (!partyInfoResponse.ok) {
						throw new Error(
							"Network response was not ok " +
								partyInfoResponse.statusText
						);
					}
					const partyInfoData = await partyInfoResponse.json();
					document.getElementById("Party_info").innerHTML =
						JSON.stringify(partyInfoData.data, null, 2);

					const csrfToken = await getCsrfToken();
					await postData(csrfToken);
				} catch (error) {
					console.error("Error:", error);
					document.getElementById(
						"postResponse"
					).textContent = `Error: ${error}`;
				}
				console.log("[debug]: fetched data - all ok");
				return true;
			}

			const conversation = document.getElementById("conversation");
			const messages = [];
			const systemPrompt = `You are a helpful Anti Money Laundering AI tool of a bank. You're used to reading and understanding complex JSON representations of alerts and can get why they're flagged based on filtered transactions and customer information. You are helping an  Investigator make sense of the alerts that they're receiving by providing informative and actionable insights and discussing any issues that they're having, while not being afraid to admit your own ignorance and say that the answer may be unclear from just the data provided.

			Make sure to output responses that are easy to understand and actionable.`;
			const systemMessage = {
				role: "assistant",
				content: systemPrompt
			};
			messages.push(systemMessage);

			document
				.getElementById("chatForm")
				.addEventListener("submit", function () {
					console.log("[debug]: form submitted");
					event.preventDefault();
					console.log("[debug]: called api button");

					const apiKey =
						document.getElementById("apiKeyContainer").textContent;
					const apiUrl = "https://api.openai.com/v1/chat/completions";

					const model = document.getElementById("model").value;

					console.log("[debug]: ", apiKey);

					let userPrompt = `Please review the following account activity and identify any suspicious patterns or behaviors that could indicate potential money laundering. Focus on analyzing any large transactions, unusual frequency of activities, or connections to high-risk jurisdictions. Provide a detailed case narrative that includes an overview of the activity, specific transaction details, behavioral indicators, and how these activities align with the customer's KYC profile. Conclude with a risk assessment and recommendations for further action, such as enhanced due diligence or filing a SAR. You may respond in Markdown.`;

					const newMessage = {
						role: "user",
						content: userPrompt
					};

					userPrompt = `${userPrompt}

						Filtered Scenario Fired Events: ${
							document.getElementById("scenario_fired_event")
								.textContent
						}

						Filtered transactions: ${document.getElementById("transactions").textContent}

						Personal information on the customer: ${
							document.getElementById("Party_info").textContent
						}`;

					newMessage.content = userPrompt;
					messages.push(newMessage);
					const form = document.getElementById("chatForm");
					// add display none to all children of form
					for (let i = 0; i < form.children.length; i++) {
						form.children[i].style.display = "none";
					}

					console.log("[debug]: prompt: ", userPrompt);
					console.log("[debug]: model: ", model);

					const loading =
						document.getElementById("loading-indicator");
					loading.classList.toggle("loading");
					autoGrow(conversation);

					fetch(apiUrl, {
						method: "POST",
						headers: {
							"Content-Type": "application/json",
							Authorization: "Bearer " + apiKey
						},
						body: JSON.stringify({
							model: model,
							messages: messages.map(message => {
								return {
									role: message.role,
									content: message.content
								};
							})
						})
					})
						.then(response => response.json())
						.then(data => {
							loading.classList.toggle("loading");
							console.log("[debug]: chatgpt response", data);
							const content = data.choices[0].message.content;
							const inputTokens = data.usage.prompt_tokens;
							const outputTokens = data.usage.completion_tokens;

							const responseMessage = {
								role: "assistant",
								content: content
							};
							addMessage(responseMessage);
							messages.push(responseMessage);
							console.log("[debug]: messages", messages);

							// log it to job execution
							callJob(inputTokens, outputTokens);
						})
						.catch(error => {
							loading.classList.toggle("loading");
							console.error("[debug]: Error:", error);
							document.getElementById(
								"chatgptResponse"
							).textContent =
								"Error occurred while fetching API data.";
						});
				});

			function addMessage(message) {
				const messageElement = document.createElement("md-block");
				messageElement.classList.add("message");
				messageElement.classList.add(message.role + "-response");
				messageElement.innerHTML = message.content;
				conversation.appendChild(messageElement);
				autoGrow(conversation);
			}

			// calls the job on SASJobExecution
			async function callJob(inputTokens, outputTokens) {
				console.log("[debug]: called job execution");
				const vajson = {
					inputTokens: inputTokens,
					outputTokens: outputTokens
				};

				const paramStr =
					"?_program=" +
					encodeURIComponent("/Public/Report/Prices") +
					"&_action=" +
					encodeURIComponent("execute") +
					"&_outputType=ods_html5" +
					"&vajson=" +
					encodeURIComponent(JSON.stringify(vajson));
				+"&_debug=log";

				try {
					const url = "/SASJobExecution/" + paramStr;

					console.log("[debug]: Job URL: ", url);
					// console.log("[debug]: vajson ", vajson);

					const requestHeaders = new Headers();
					requestHeaders.append("Accept", "text/html");

					const requestOptions = {};
					requestOptions.headers = requestHeaders;
					requestOptions.method = "GET";

					const response = await fetch(url, requestOptions);

					if (!response.ok) {
						const error = response.statusText;
						console.log("[debug]: Job failed with error: ", error);
					}

					const jobOutput = await response.text();
					// console.log("[debug]: Job output: ", jobOutput);
					return jobOutput;
				} catch (error) {
					console.error("************** JOB FAILED ***************");
					console.error("[debug]: Error: ", error);
				}
			}

			// Fetch data on page load
			document.addEventListener("DOMContentLoaded", function () {
				fetchData();
			});
		</script>
	</body>
</html>
